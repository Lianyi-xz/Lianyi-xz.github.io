<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins部署]]></title>
    <url>%2FDevops_Jinkens_install.html</url>
    <content type="text"><![CDATA[经果四天的研究，我成功变成了智障 有缘再看吧 docker 运行Jenkins12345678docker run \ --rm \ -u root \ -p 8080:8080 \ -v jenkins-data:/var/jenkins_home \ -v /var/run/docker.sock:/var/run/docker.sock \ -v "$HOME":/home \ jenkinsci/blueocean 参考文档官方文档]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Swarm 实验]]></title>
    <url>%2FDevops_Docker_Swarm_example.html</url>
    <content type="text"><![CDATA[基本环境 manager：10.10.0.132 work1：10.10.0.133 work2：10.10.0.134 创建swarm1234docker swarm init --advertise-addr 10.10.0.132 #初始化Docker引擎集群docker info #查看swarm状态docker node ls #查看swarm相关节点docker swarm ca --rotate #生成新的CA证书和密钥 swarm中添加节点12345678docker swarm join-token worker #检索worker的添加命令docker swarm join-token --rotate worker #生成新的worker令牌docker swarm join-token manager #检索manager的添加命令docker node promote &lt;node name&gt; #工作节点提升为管理节点docker node demote &lt;node name&gt; #管理节点降级为工作节点docker swarm join \ #添加工作节点到swarm --token SWMTKN-1-34lurdcnbjpbxszzi47gw2l8hbjdzy7vjzcxe38ay776pbe8lj-9ao0aojs37006socamuioe3ht \ 10.10.0.132:2377 查看节点信息123docker node inspect node_iddocker node inspect --pretty node_iddocker swarm leave #离开swarm 部署应用服务12345docker service create \ --replicas 1 \ #在一个容器上运行服务 --name hello \ #服务名称 centos \ #服务所使用镜像，不加标签 默认使用 laster镜像，服务运行节点需存在镜像 ping 10.10.0.134 #容器运行的服务 查看swarm运行服务123docker service inspect service_name #查看服务详细信息docker service inspect --pretty service_namedocker service ps service_name #查看服务在那些节点运行 修改服务运行容器数量1docker service scale &lt;SERVICE-ID&gt;=&lt;NUMBER-OF-TASKS&gt; 删除服务1docker service rm service_name 服务更新1docker service update &lt;SERVICE-ID&gt; 服务滚动更新(创建服务时添加)12--update-delay 10s 配置更新服务任务或任务组之间的时间延迟--update-parallelism 配置调度程序同时更新的最大服务任务数。 排空一个节点1docker node update --availability drain &lt;NODE-ID&gt; 发布服务端口1docker service create --name ser_name --publish published=主机端口,target=容器端口 image 发布现有服务端口1docker service update --publish-add published=主机端口,target=容器端口 service_name 查看服务发布端口1docker service inspect --format="&#123;&#123;json .Endpoint.Spec.Ports&#125;&#125;" service_name 仅发布udp端口12--publish published=53,target=53,protocol=udp-p 53:53/udp]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Swarm(集群)]]></title>
    <url>%2FDevops_Docker_Swarm_base.html</url>
    <content type="text"><![CDATA[Swarm模式 Docker1.12.0或更高版本 使用Docker CLI 创建Swarm，将应用程序部署到swarm，并管理swarm行为 当前版本Docker包含swarm模式，用于本地管理的docker引擎集群被称为swarm swarm概念 swarm是由多个Docker主机组成，这些主机以swarm模式运行 分为管理者(管理成员和委托)和工作者(运行swarm服务) 给定Docker主机可以是管理者、工作者，或执行这两个角色 修改服务配置，无需重新启动服务 可在参与swarm的任何Docker主机以及swarm服务商运行独立容器 可以定义并运行swarm服务 节点 节点是docker引擎参与swarm的一个实例，可视为Docker节点 可在单台物理计算机或云服务器上运行一个或多个节点 生产swarm部署通常包括分布在多台物理机和云计算机上的Docker节点 若将应用程序部署到swarm，需要将服务定义提交给管理节点，管理节点将称为任务的工作单元分配给工作节点 服务和任务 服务是任务的定义，在管理或工作节点执行 创建服务时，指定使用那个容器镜像以及在运行容器中执行那些命令 对于复制服务模型，swarm管理器根据所需状态中设置的比例在节点之间分配指定数量的副本任务 对于全局服务，swarm在集群中的每个可用节点上运行一项服务任务 一个任务携带Docker容器和在容器内运行的命令，是swarm的原子调度单位。 管理器节点根绝服务规模中设置的副本数量将任务分配给工作节点，一旦任务分配给一个节点，他就不能移动到另一个节点，只能在分配的节点上运行或失败。 负载均衡 swarm管理器使用入口负载均衡来暴露对swarm外部提供的服务 swarm管理器可自动将服务分配给一个PublishedPort(30000-32767)，可配置 外部组件可以访问swarm中任何节点的已发布端口上的服务 Swarm模式有一个内部的DNS组件，可以自动为swarm中的每个服务配置一个DNS条目]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Registry(私有仓库)]]></title>
    <url>%2FDevops_Docker_registry.html</url>
    <content type="text"><![CDATA[Registry:官方提供用于构建私有镜像仓库的工具 Registry 基本配置1234567docker run -d -e REGISTRY_HTTP_ADDR =0.0.0.0:5001 #registry侦听容器内的5001端口 -p 5001:5001 #主机端口:容器内端口 --name #设置容器名称 --restart=always #为registry配置重新启动策略 -v /mnt/registry:/var/lib/refistry #主机目录:容器目录 设置目录挂载 registry:2 registry镜像名 运行 Registry123456789101112131415161718#下载registry镜像 docker pull registry.docker-cn.com/library/registry:2 docker tag registry.docker-cn.com/library/registry:2 registry:2 标记镜像 #启动registry镜像 docker run -d -p 5000:5000 --name registry registry:2#标记镜像，指向本地registry docker tag lianyi/ubuntu:v1.0 localhost:5000/ubuntu:v1.0#推送镜像到本地registry docker push localhost:5000/ubuntu:v1.0#删除本地缓存 images docker image rm localhost:5000/ubuntu:v1.0 #关闭本地registry 并删除所有数据 docker stop registry &amp;&amp; docker rm -v registry 参考文档官方文档开启https基本认证使用Compose文件部署registry]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Hub (公有仓库)]]></title>
    <url>%2FDevops_Docker_hub.html</url>
    <content type="text"><![CDATA[网址Docker Hub 登陆 docker login 命令来输入用户名、密码和邮箱完成注册和登陆 注册成功后，本地用户目录的.dockercfg中奖保存用户的认证信息 基本操作123docker search #查找官方仓库中的镜像docker pull #下载镜像到本地docker push #上传镜像到仓库]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Container (容器)]]></title>
    <url>%2FDevops_Docker_container.html</url>
    <content type="text"><![CDATA[运行容器1234567891011121314151617181920212223#基于镜像运行容器 docker run -t -i ubuntu:14.04 /bin/bash #-t 分配一个伪终端并与容器绑定 #-i 让容器标准输入保持打开 #-d 在后台运行容器并打印容器ID #--name 为容器自定义命名 #--rm 容器终止后立刻删除，--rm与-d参数不能同时使用 #容器是一个服务 运行/bin/bash有将其做虚拟机使用的悬疑。。。 #查看运行容器docker ps#查看终止状态容器docker ps -a#停止容器docker stop [CONTAINER ID]#启动已终止容器docker start [CONTAINER ID]#重启容器docker restart 进入容器123456789#attach命令#当多个窗口同时attach到一个容器的时候，所有窗口都会同步显示 docker attach [CONTAINER ID/NAMES] #nsenter命令#在util-linux包2.23版本后包含，若无需安装#nsenter 可以访问另一个进程的名字空间，需root权限 PID=$(docker inspect --format "&#123;&#123; .State.Pid &#125;&#125;" [CONTAINER ID]) nsenter --target $PID --mount --uts --ipc --net --pid 删除容器12#删除在运行的容器，可以添-f参数docker rm [CONTAINER ID] 其它相关命令12345678#守护态运行 #启动时添加 -d 参数#查看容器名字 docker inspect -f "&#123;&#123; .Name &#125;&#125;" [CONTAINER ID] #获取容器的输出信息 docker logs [docker names]]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker CE 安装]]></title>
    <url>%2FDevops_Docker_install.html</url>
    <content type="text"><![CDATA[安装步骤仅为参考，疑问请参考官方文档 系统要求 Zesty 17.04 Xenial 16.04 (LTS) Trusty 14.04 (LTS) 卸载旧版本Docker1sudo apt-get remove docker &lt;!-- more --&gt;docker-engine docker.io 更换默认存储驱动程序Docker默认使用overlay2，官方建议替换为aufs，在此未作配置修改。 安装Docker CE12345678910111213141516171819#更新包索引sudo apt-get update#安装软件包,以允许apt通过HTTPS使用存储库sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common#添加Docker的官方GPG密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -#设置软件源信息sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"#更新并安装Docker CEsudo apt-get -y updatesudo apt-get -y install docker-ce 安装指定版本的Docker CE12345#查找Docker-CE的版本apt-cache madison docker-ce#安装指定版本的Docker CEsudo apt-get -y install docker-ce=[VERSION] docker授权12#将操作 docker 用户，加入 docker 组，为该用户赋予操作 docker 的权限sudo usermod -aG docker $USER 参考文档Docker GuidesAliyun Docker CE 镜像源站Docker Guides AUFS storage]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK日志平台]]></title>
    <url>%2FDevops_ELK_base.html</url>
    <content type="text"><![CDATA[ELK简介ELK:集中式WEB日志收集平台ELK=ElasticSearch+Logstash+Kiabana ElasticSearch：开源分布式搜索引擎 Logstash：开源日志收集、过滤工具 Kiabana：提供web界面 未写完 先看一下 jenkins]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Image (镜像)]]></title>
    <url>%2FDevops_Docker_image.html</url>
    <content type="text"><![CDATA[获取镜像12345docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;#Registry地址 &lt;域名/IP&gt;[:端口号] 默认地址是Docker Hub#仓库名 &lt;用户名&gt;/&lt;软件名&gt; 对于Docker Hub 不给出仓库名默认为Library(官网镜像)#docker pull registry.docker-cn.com/library/ubuntu:14.04 列出镜像12345678910111213#列出顶级镜像docker images#列出中间镜像docker images -a #列出部分镜像docker images 仓库名 标签# 虚悬镜像#仓库名和标签均为&lt;none&gt;的镜像#删除虚悬镜像docker rmi $(docker images -q -f dangling=true) 创建镜像利用DockerFile创建镜像 存入和载出镜像利用仓库来存入和载出镜像 删除本地镜像12#删除镜像之前使用 docker rm 删除依赖该镜像的所有容器docker rmi 镜像名:标签]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 镜像加速器]]></title>
    <url>%2FDevops_Docker_Image_accelerator.html</url>
    <content type="text"><![CDATA[常用加速器1234567#Docker 官方的中国镜像加速器https://registry.docker-cn.com#中国科技大学的镜像加速器https://docker.mirrors.ustc.edu.cn/#其它（需登陆）https://cr.console.aliyun.com/#/accelerator #阿里云加速器https://www.daocloud.io/mirror#accelerator-doc #DaoCloud加速器 Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统） 1234567891011#编辑配置文件sudo vim /etc/default/docker#添加加速器地址DOCKER_OPTS="--registry-mirror=https://registry.docker-cn.com"#重启 Docker 引擎sudo service docker restart#查看配置sudo ps -ef | grep dockerd Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）123456789101112#编辑配置文件sudo vi /etc/systemd/system/multi-user.target.wants/docker.service#添加加速器地址ExecStart=/usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com#重新加载配置并启动服务sudo systemctl daemon-reloadsudo systemctl restart docker#查看配置sudo ps -ef | grep dockerd 参考文档Docker问答录]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker概念]]></title>
    <url>%2FDevops_Docker_base.html</url>
    <content type="text"><![CDATA[镜像 一个特殊的文件系统，包含了操作系统完整的root文件系统 提供容器运行时所需的程序、库、资源、配置等文件 包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等） 容器 镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停 实质是进程，运行于属于自己的独立的命名空间 容器进程直接运行于宿主内核中 运行时会创建一个为容器运行时读写而准备的存储层：容器存储层 仓库 集中的存储、分发镜像 可包含多个仓库，每个仓库可以包含多个标签，每个标签对应一个镜像 使用&lt;仓库名&gt;:&lt;标签&gt; 指定具体软件版本的镜像，不给出标签默认使用latest标签 参考文档Docker —— 从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 中ASCII显示图片]]></title>
    <url>%2FLinux_image.html</url>
    <content type="text"><![CDATA[在ubuntu中实现，且并没有什么实用价值的小技能 安装ImageMagick1sudo apt-get install imagemagick 安装aview1sudo apt-get install aview 执行转换命令12#psb.jpg 为需要转换的图片asciiview psb.jpg -driver curses 效果展示]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux sudo详解]]></title>
    <url>%2FLinux_sudo.html</url>
    <content type="text"><![CDATA[使得用户以其他用户的身份通过主机执行命令 简介123456789101112#默认保存权限5分钟#配置文件/etc/sudoers#语法#谁 在那个主机=(以谁的身份) 执行什么命令who which_hosts=(runas) commands eg： xx ALL=(root) /usr/sbin/useradd,/usr/sbin/usermodsudo -k #不保存权限 -l #列出当前用户可以使用的所有的sudo类命令 别名12345678910111213141516171819202122232425262728#别名必须全部而且只能使用大写英文字母#可使用！ 取反#用户别名who:User_AliasUser_Alias USERADMIN= #用户的用户名 #组名，使用%引导 #还可以包含其它已经定义的用户别名#主机别名which_hosts:Host_Alias #主机名 #ip #网络地址 #其他主机别名 #运行用户别名 runas:Runas_Alias #用户名 #%组名 #其他Runas别名 #命令别名command:Cmnd_Alias #命令路径 #目录(此目录内的所有命令) #其他事先定义过的命令别名 已经看不懂了…..]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 禁止root远程登陆]]></title>
    <url>%2FLinux_root.html</url>
    <content type="text"><![CDATA[创建新用户1useradd xx 添加用户到root组1usermod -g root xx 添加用户sudo权限12vim /etc/sudoers xx all all 限制ssh12vim /etc/ssh/sshd_config#PermitRootLogin yes 取消注释改为no 重启ssh1234#centos6service sshd reload#centos7systemctl restart sshd.service]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 免密登陆]]></title>
    <url>%2FLinux_ssh.html</url>
    <content type="text"><![CDATA[配置Linux主机ssh无密码访问1234567#使用ssh-keygen与ssh-copy-id实现快速证书的生成及公钥下发#生成一对密钥 ssh-keygen #下发生成的公钥 ssh-copy-id username@ip or ssh-copy-id -i /root/.ssh/id_rsa.pub root@ip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux firewalld设置]]></title>
    <url>%2FLinux_firewall.html</url>
    <content type="text"><![CDATA[firewalld 基本使用12345678910111213141516#启动 systemctl start firewalld#停止systemctl disable firewalld#查看状态 systemctl status firewalld #重启systemctl restart firewalld#禁用 systemctl stop firewalld#开机启动systemctl enable firewalld#开机禁用systemctl disable firewalld#是否开机启动systemctl is-enabled firewalld 配置firewalld-cmd1234567891011121314151617181920#查看版本firewall-cmd --version#查看帮助firewall-cmd --help#显示状态firewall-cmd --state#查看所有打开的端口firewall-cmd --zone=public --list-ports#更新防火墙规则firewall-cmd --reload#查看区域信息firewall-cmd --get-active-zones#查看指定接口所属区域firewall-cmd --get-zone-of-interface=eth0#拒绝所有firewall-cmd --panic-on#取消拒绝状态firewall-cmd --panic-off#查看是否拒绝firewall-cmd --query-panic 端口12345678#添加 （--permanent永久生效，没有此参数重启后失效）firewall-cmd --zone=public --add-port=80/tcp --permanent #重新载入firewall-cmd --reload#查看firewall-cmd --zone= public --query-port=80/tcp#删除firewall-cmd --zone= public --remove-port=80/tcp --permanent 服务123456#添加firewall-cmd --add-service=ftp --zone=public --permanent#删除firewall-cmd --remove-service=ftp --zone=public#查看服务是否被允许firewall-cmd --query-service=http --zone=public 富规则123456789101112#查看firewall-cmd --list-rich-rules#添加 #禁止特定端口访问ssh/22 firewall-cmd --permanent --zone=public --add-rich-rule="rule family=ipv4 source address='x.x.x.x/24' service name='ssh' drop" or firewall-cmd --permanent --zone=public --add-rich-rule="rule family='ipv4' source address='x.x.x.x/24' service name='ssh' reject" firewall-cmd --permanent --zone=public --add-rich-rule="rule family='ipv4' source address='x.x.x.x/24' port port=22 protocol=tcp reject" #允许ip访问 ssh firewall-cmd --permanent --zone=public --add-rich-rule="rule family=ipv4 source address='x.x.x.x/24' port port=22 protocol=tcp accept"#删除firewall-cmd --remove-rich-rule 'rule family=ipv4 source address=x.x.x.x/24 service name=ftp accept']]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫：xpath 提取数据]]></title>
    <url>%2FPython_Crawlwe_xpath.html</url>
    <content type="text"><![CDATA[lxml 安装1pip install lxml xpath引用1from lxml import etree XPath表达式12345678910111213#XPath基本语法 / #从根节点选取 // #选择任意位置的某个节点 | #选取若干个路径 . #选取当前节点 .. #选取当前节点的父节点 @ #选取属性/text() #提取文本内容/@xxxx #提取属性内容//td #选择所有的td元素//div[@calss="mine"] #选择所有具有class=mine属性的div元素&lt;html&gt;.xpath("/html/head/title") #选择html中head标签的title元素 Chrome 获取xpath 打开Chrome浏览器 进入开发者工具 右键相应标签-Copy-Copy XPath 参考文档我的脚本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫：Beautiful Soup库-提取数据]]></title>
    <url>%2FPython_Crawler_bs4.html</url>
    <content type="text"><![CDATA[beautifulsoup安装1pip install beautifulsoup4 beautifulsoup引用12from bs4 import BeautifulSoupimport bs4 Beatiful Soup类基本元素12345Tag #标签 &lt;tag&gt; 整个html文件Name #标签的名字 &lt;tag&gt;.nameAttributes #标签属性 &lt;tag&gt;.attrs 数组形式NavigableString #标签内容 &lt;tag&gt;.stringComment #标签内容注释部分 &lt;tag&gt;.string Html内容遍历方法123456789101112#上行遍历 .parent #父节点标签 .parents #节点先辈标签的迭代类型#下行遍历 .contents #子节点列表 .children #子节点的迭代类型 .deseendants #子孙节点的迭代类型#平行遍历(同一个父节点) .next_sibling #下一个平行节点 .previous_sibling #上一个平行节点 .next_siblings #所有后续平行节点 .previous_siblings #所有前续平行节点 find_all方法123456789101112&lt;tag&gt;(..) eq &lt;tag&gt;.find_all(..)soup(..) eq soup.find_all(..).find_all(name,attrs,recursive,string,**kwargs) name： #对标签名称的检索字符串 attrs: #对标签属性值的检索字符串，可标注属性检索 recursive: #是否针对所有子孙节点搜索，默认True string: #对标签内容进行检索 soup.find_all(id="link2")soup.find_all("a", class_="sister")soup.find_all("a", attrs=&#123;"class": "sister"&#125;) 参考文档我的脚本Beautiful Soup 4.2.0]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫：request库获取页面]]></title>
    <url>%2FPython_Crawler_request.html</url>
    <content type="text"><![CDATA[requests安装1pip install requests Requests Requests：对html操作 1234567891011121314151617181920#Requests七个主要方法 request() #构造一个请求 get() #获取html网页 head() #获取html头信息 post() #向html提交post请求 增 put() #提交put请求 改(改所有字段) patch() #提交局部修改请求 改 delete() #提交删除请求 #Requests库异常 ConnectionError HTTPError URLRequired #url缺失 TooManyRedirects #最大重定向次数 ConnectTimeout #链接超时 Timeout #请求超时 #获取一个网页 r = requests.get(url) requests.get(url,params=None,**kwargs) Response Response：html返回内容 123456789#Response对象的属性 r.status_code #http请求返回状态 r.text #http响应内容的字符串形式 r.encoding #http的头部猜测(charset)的响应内容编码方式 r.apparent_encoding #http内容中分析的响应内容编码方式 r.content #http响应的二进制形式 #Response异常 r.raise_for_status() #判断r.status_code是否为200，否 返回异常 **kwargs控制访问参数12345678910111213params #字典或字节序列，作为参数添加到url中data #字典、字节序列或文件对象,作为Request的内容json #json格式的数据，作为Request内容headers #字典，http定制头 hd = &#123;'user-agent':'Chrome/10 '&#125; Mozilla/5.0cookies #字典或CookieJar,Request中的cookieauth #元祖，支持HTTP认证功能files #字典，传输文件 fs = &#123;'file':open('data.xls','rb')&#125;timeout #设置超时时间，单位为秒proxies #字典，设定访问代理服务器，可增加登录认证allow_redirects #True/False 是否允许重定向stream #是否立即下载内容 默认Tureverify #ssl证书开关，默认Truecert #本地ssl证书路径 参考文档我的脚本中文requests英文requests]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 模板(V)]]></title>
    <url>%2FPython_Django_templates.html</url>
    <content type="text"><![CDATA[创建模板文件夹1mkdir projecct_name/app_name/templates/app_name 模板基本操作12345678#编辑应用首页模板edit projecct_name/app_name/templates/app_name/index.html#嵌入代码&#123;% code %&#125;#嵌入变量&#123;&#123; var &#125;&#125;#嵌入 url, url_name 为设置url.path时填写的name内容&#123;% url 'app_name:url_name' var%&#125; if语句12345&#123;% if a %&#125; &#123;&#123; a &#125;&#125;&#123;% else %&#125; &lt;p&gt; empty&lt;/p&gt;&#123;% endif %&#125; 静态文件123456edit projecct_name/app_name/templates/app_name/index.html&#123;#加载静态文件#&#125;&#123;% load static %&#125;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &apos;polls/css/style.css&apos; %&#125;&quot; /&gt;&lt;img src=&quot;&#123;% static &apos;polls/images/one.jpg&apos; %&#125;&quot; alt=&quot;静态图片&quot; &gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 静态文件]]></title>
    <url>%2FPython_Django_static.html</url>
    <content type="text"><![CDATA[创建静态文件1234#创建 css、js、图片文件夹 mkdir projecct_name/app_name/static/app_name/css/ mkdir projecct_name/app_name/static/app_name/js/ mkdir projecct_name/app_name/static/app_name/images/ 编辑静态文件1234567edit projecct_name/app_name/static/app_name/css/style.cssli a &#123; color : green ; &#125;body &#123; background : white url （"../images/background.gif"） no-repeat right bottom ; &#125; 使用静态文件123456edit projecct_name/app_name/templates/app_name/index.html&#123;#加载静态文件#&#125;&#123;% load static %&#125;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &apos;polls/css/style.css&apos; %&#125;&quot; /&gt;&lt;img src=&quot;&#123;% static &apos;polls/images/one.jpg&apos; %&#125;&quot; alt=&quot;静态图片&quot; &gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 通用视图]]></title>
    <url>%2FPython_Django_generic.html</url>
    <content type="text"><![CDATA[并不能git到有什么作用 通用视图简介 快捷地将数据库数据呈现在网页上 在控制器(view.py)中编写 通用表单分为： TemplateView：只返回模板 ListView：返回某model中的所有数据 DetailView：返回每个数据的详细信息 使用步骤 修改url配置 创建通用视图类 基于Django的通用视图引入新的视图 修改url配置1234567891011edit create project_name/app_name/urls.pyfrom django.urls import pathfrom . import viewsapp_name = &apos;app_name&apos;urlpatterns = [ path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;), #使用IndexView 通用视图类 path(&apos;&lt;int:pk&gt;/&apos;, views.DetailView.as_view(), name=&apos;detail&apos;), path(&apos;&lt;int:pk&gt;/results/&apos;, views.ResultsView.as_view(), name=&apos;results&apos;), path(&apos;&lt;int:question_id&gt;/vote/&apos;, views.vote, name=&apos;vote&apos;),] 修改控制器1234567891011121314151617181920212223edit create project_name/app_name/view.pyfrom django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirectfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = &apos;app_name/index.html&apos; context_object_name = &apos;latest_question_list&apos; def get_queryset(self): &quot;&quot;&quot;Return the last five published questions.&quot;&quot;&quot; return Question.objects.order_by(&apos;-pub_date&apos;)[:5]class DetailView(generic.DetailView): model = Question template_name = &apos;app_name/detail.html&apos;class ResultsView(generic.DetailView): model = Question template_name = &apos;app_name/results.html&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 表单]]></title>
    <url>%2FPython_Django_form.html</url>
    <content type="text"><![CDATA[简单的表单案例 视图部分123456789101112131415edit projecct_name/app_name/templates/app_name/detail.html&#123;#method=&quot;post&quot; 修改数据#&#125;&lt;form action=&quot;&#123;% url &apos;polls:vote&apos; question.id %&#125;&quot; method=&quot;post&quot;&gt; &#123;#防止跨站点请求伪造#&#125; &#123;% csrf_token %&#125; &#123;% for choice in question.choice_set.all %&#125; &#123;#forloop.counter表示for标签已经经过了多少次循环 #&#125; &lt;input type=&quot;radio&quot; name=&quot;choice&quot; id=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot; value=&quot;&#123;&#123; choice.id &#125;&#125;&quot; /&gt; &lt;label for=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot;&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt; &lt;br /&gt; &#123;% endfor %&#125; &#123;# 将选中单选项的 value值以post的方式传递给 &apos;polls:vote&apos;#&#125; &lt;input type=&quot;submit&quot; value=&quot;Vote&quot; /&gt;&lt;/form&gt; 控制器部分1234567891011121314151617181920212223#导入 Question,Choice 模型from .models import Question,Choicefrom django.http import HttpResponseRedirect,HttpResponsefrom django.urls import reverse#使用模板简写 import 内容from django.shortcuts import render,get_object_or_404def vote(request,question_id): question = get_object_or_404(Question,pk=question_id) try: #request.POST ：通过密钥访问提交的数据 # request.POST[&apos;choice&apos;]以字符串形式返回所选选项的ID #在与question外键关联的choice中获取某条的choice selected_choice = question.choice_set.get(pk=request.POST[&apos;choice&apos;]) except (KeyError,Choice.DoesNotExist): context = &#123;&apos;question&apos;:question,&apos;error_message&apos;:&quot;you didn&apos;t select a choice.&quot;&#125; return render(request,&apos;polls/detail.html&apos;,context) else: #该条choice 的votes字段+1 并保存 selected_choice.votes += 1 selected_choice.save() #y用户被重定向的rul return HttpResponseRedirect(reverse(&apos;polls:results&apos;,args=(question.id,))) 模型部分]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 模型(M)]]></title>
    <url>%2FPython_Django_model.html</url>
    <content type="text"><![CDATA[部分字段类型123456789101112#递增整数：AutoField#布尔值：BooleanField#字符串类型：CharField#文本类型：TextField#日期类型：DateField#时间类型：DateTimeField#数值型：IntegerField#浮点数类型：FloatField#Email型：EmailField#文件上传：FileField #必须有的参数： upload_to#图片类型：ImageField#外键：ForeignKey 字段类型参考文档 创建模型12345678910from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 修改模型默认提示信息123class Question(models.Model): def __str__(self): return self.question_text 添加自定义方法12345import datatimefrom django.utils import timezoneclass Question(models.Model): def was_published_recently(self): return self.pub_date &gt;=timezone.now()-datatime.timedelta(days=1) 单独迁移app_name应用1python manage.py makemigrations app_name 查看迁移内容1python manage.py sqlmigrate app_name 0001 执行迁移操作1python manage.py migrate]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 控制器(C)]]></title>
    <url>%2FPython_Django_views.html</url>
    <content type="text"><![CDATA[import 模块12345# 当前文件夹 models.py文件中导入Question数据表from .models import Question#使用模板简写 和404问题from django.shortcuts import render,get_object_or_404 编辑控制器1234567891011121314151617181920def index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123; 'latest_question_list':latest_question_list&#125; #使用模板简写 return render(request,'polls/index.html',context) #使用模板 #template = loader.get_template('polls/index.html') #return HttpResponse(template.reder(context,request)) def detail(request,question_id): #404 问题 # try: # question = Question.objects.get(pk=question_id) # except Question.DoesNotExist: # raise Http404("Question does not exist") #440简写 question = get_object_or_404(Question,pk=question_id) context = &#123;'question':question&#125; return render(request,'polls/detail.html',context)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django url]]></title>
    <url>%2FPython_Django_url.html</url>
    <content type="text"><![CDATA[添加应用路径前，需创建应用 添加应用路径12345678910create project_name/app_name/urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'), #path(路径route，视图view，字典参数kwargs，url命名name) path('&lt;int:question_id&gt;/',views.detail,name='detail'), path('&lt;int:question_id&gt;/results/',views.results,name='results'), path('&lt;int:question_id&gt;/vote/',views.vote,name='vote'),] 声明应用路径12345678edit project_name/project_name/urls.pyfrom django.urls import include, pathfrom django.contrib import adminurlpatterns = [ path('app_name/', include('app_name.urls')), path('admin/', admin.site.urls),]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 基本操作]]></title>
    <url>%2FPython_Django_base.html</url>
    <content type="text"><![CDATA[创建Django1234567891011121314#查看django版本python -m django --version#创建新项目 django-admin startproject project_name #开发环境运行 python manage.py runserver [ip:port]#创建应用 python manage.py startapp app_name #创建管理网站用户 python manage.py createsuperuser Django 项目默认文件1234567project_name/ #项目的容器，可重命名 manage.py #命令行程序，可与项目交互 project_name/ #项目包，需要用来导入任何内容的python包名(eg:project_name.urls) __init__.py #空的文件，该目录应该被认为是一个Python包 settings.py #项目的设置/配置 urls.py #URL声明 wsgi.py #WSGI兼容的Web服务器为您的项目提供服务的入口点 Django 应用默认文件123456789app_name/ __init__.py admin.py apps.py migrations/ #模型迁移文件，用于创建或撤销数据表 __init__.py models.py #模型，存放程序数据表 M tests.py views.py #控制器，管理页面内容 C 激活Django应用1234567891011edit peoject_name/project_name/settings.pyINSTALLED_APPS = [ 'app_name.apps.AppNameConfig'， #AppNameConfig为app_name/apps.py中定义的类名 'django.contrib.admin'， 'django.contrib.auth'， 'django.contrib.contenttypes'， #内容类型框架 'django.contrib.sessions'， 'django.contrib.messages'， #消息框架 'django.contrib.staticfiles'， #管理静态文件的框架]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 连接mysql]]></title>
    <url>%2FPython_Django_mysql.html</url>
    <content type="text"><![CDATA[仅适用于python3 安装mysqlclient1pip install mysqlclient 管理mysql123create database app_name CHARACTER SET UTF8;grant all privileges on app_name.* to 'db_user'@'192.168.0.49'identified by 'db_passwd' with grant;FLUSH PRIVILEGES; 修改setting.py文件12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'polls', 'HOST':'192.168.1.91', #数据库所在地址，需提供外部访问权限 'PORT':'3306', 'USER':'db_user', 'PASSWORD':'db_passwd', &#125;&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 重定向与管道]]></title>
    <url>%2FLinux_Shell_pipline.html</url>
    <content type="text"><![CDATA[数据重定向 标准输入stdin：代码为0，使用&lt;或&lt;&lt; 准输出stdout：代码为1，使用&gt;或&gt;&gt; 标准错误输出stderr：代码为2，使用2&gt;或2&gt;&gt;>输出到一个已存在的文件中，那个文件就会被覆盖掉>&gt;输出到一个已存在的文件中，数据会在文件最下方累加进去 案例find /home -name .bashrc 2&gt; /dev/null stderr被丢弃find /home -name .bashrc &amp;&gt; /dev/null 所有输出被丢弃 命令执行的判断依据 ； &amp;&amp; || 管道命令 仅处理经由前面一个命令传来的正确信息 选取命令cut，grep 1234567891011cut -dfc -d 后跟分割符号 -f 依据-d的分割字符将遗传信息分割成数段，-f取出第几段 -f 3 -f 3,5 -c 以字符的单位取出固定字符区间 12- 12-20grep -acinv '查找字符串' filename -a 将二进制文件以txt文件的方式查找 -c 计算找到'查找字符串'的次数 -i 忽略大小写 -n 输出行号 -v 反向选择，输出没有'查找字符串'内容的行 排序命令 sort、wc、uniq 123456789101112131415161718sort -fbMnrtuk [file or stdin] -f 忽略大小写差异 -b 忽略最前端空格 -M 以月份来排序 -n 使用纯数字进行排序，默认以文字类型来排序 -r 反向排序 -u uniq 相同的数据仅出现一行代表 -t 分隔符，默认是用Tab键来分隔 -k 以那个区间[field]来进行排序的意思wc -lwm -l 仅列出行 -w 仅列出多少字 -m 多少字符uniq -ic -i 忽略大小写 -c 进行计数 双向重定向 tee 12tee 同时将数据流送与文件与屏幕 字符转换命令 tr、col、join、paste、expand 1234567891011121314151617181920tr -ds set1 ... -d 删除信息中set1这个字符串 -s 替换掉重复的字符 col -xb -x 将tab键转化成对等的空格键 -b 在文字中有/时，仅保留/最后接的字符join -ti12 file1 file2 -t 默认以空格符分隔数据，并对比第一个字段的数据，若两个文件相同，则将两条数据连成一行 -i 忽略大小写差异 -1 代表第一个文件要用那个字段来分析 -2 代表第二个文件要用那个字段来分析paste -d file1 file2 直接将两行贴在一起，中间用tab隔开 -d 分隔符号，默认tab - 若file写成-，表示来自stdin 的数据expand -t file -t 将tab转化成空格键，一般 一个tab可用8个空格键替换，也可以自定义一个tab代表多少字符 切割命令 split 1234split -bl file PREFIX -b 跟准备切割成的文件大小，可加单位，例如b,k,m等等 -l 以行数来切割 PREFIX 代表前导符，可作为切割文件的前导文字 参数代换 xargs 1234567很多命令不支持管道命令，因此可以通过xargs 来提供该命令引用stdin只用xargs -0pen command -0 输入的stdin中的特殊字符转化为一般字符 -p 在执行每个命令的参数时，都会询问用户的意思 -e end of file的意思 -n 次数，每次command命令执行，要使用几个参数的意思 echo '--help' | xargs cat 减号 - 1在管道中前一个命令的stdout可以作为这次的stdin，该stdin与stdout可以利用减号 - 来替代]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 变量]]></title>
    <url>%2FLinux_Shell_var.html</url>
    <content type="text"><![CDATA[变量命名规则 变量与内容使用 =号连接，=两边不加空格 变量名仅以英文和数字命名，且英文开头 转义字符\,将特殊字符转换为一般字符 ${命令}为其它命令提供信息 ${变量}累加内容 变量12345678910#查看环境变量 env#查看所有变量 set#查看所支持的语系 locale#以树状图显示进程之间的关系 pstree#声明变量类型 declare/typeset -a 数组 -i 整数 -x 环境变量 -r只读]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 终端提示符]]></title>
    <url>%2FLinux_PS1.html</url>
    <content type="text"><![CDATA[设置终端提示符步骤 修改环境变量 1vim ~/.bashrc 添加修改内容 1export PS1='\[\033[0;31m\]\342\224\214\342\224\200$([[ $? != 0 ]] &amp;&amp; echo "[\[\033[0;31m\]\342\234\227\[\033[0;37m\]]\342\224\200")[\[\033[0;39m\]\u\[\033[01;33m\]@\[\033[01;96m\]\h\[\033[0;31m\]]\342\224\200[\[\033[0;32m\]\w\[\033[0;31m\]]\n\[\033[0;31m\]\342\224\224\342\224\200\342\224\200\342\225\274 \[\033[0m\]\[\e[01;33m\]\$\[\e[0m\]' 加载环境变量 1source ~/.bashrc 图片显示 查看终端提示符设置该命令常被用于剽窃他人的终端提示符 1echo $PS1]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 定时任务]]></title>
    <url>%2FLinux_crontab.html</url>
    <content type="text"><![CDATA[crontab Linux定时任务每分钟检查一次来处理 crontab 语法crontab [-u username] [-ler] crontab参数 l：编辑crontab的工作内容 e：查看crontab的工作内容 r：移除所有crontab的工作内容 u：设定某个用户的cron服务 crontab工作内容crontab内容分为六个部分 minute： 表示分钟，可以是从0到59之间的任何整数 hour：表示小时，可以是从0到23之间的任何整数 day：表示日期，可以是从1到31之间的任何整数 month：表示月份，可以是从1到12之间的任何整数 week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 特殊字符 *：任何时刻都接受 \,：代表分隔时段 -：代表时间范围 /n：n代表数字，表达每隔n个单位 案例 30 7 8 ls 指定每月8号的7：30分执行ls命令30 3 10,20 ls 指定每月的10号及20号的3：30执行ls命令/15 ls 每15分钟执行一次ls命令 /1 sleep 3 &amp;&amp; ls 睡眠3秒再执行ls命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 文件与目录]]></title>
    <url>%2FLinux_file.html</url>
    <content type="text"><![CDATA[目录简单使用linux路径 相对路径(basename)：从某一非根目录开始的路径 绝对路径(dirname)：从根目录开始的路径 处理目录 cd：切换目录 pwd： 显示当前目录 mkdir： 新建目录 rmdir： 删除目录 ls：查看当前目录下的文件 文件简单使用文件类型 d：目录 l：连接文件 linkfile b：设备文件里面的可供存储的接口设备 c：设备文件里的串行端口文件查看 cat：查看文件全部内容 more：分屏向后查看文件内容 less：分屏前后翻查看文件内容 head：从头查看数行文件内容 tail：从后查看数行文件内容文本处理 cut：选取命令,设置分隔符进行剪切 join：拼接 sed：管道命令 按行处理 awk：分析 sort：排序 uniq：显示重复 grep：查找 diff：比较文件之间不同]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2FFirst_Hexo_Blog.html</url>
    <content type="text"><![CDATA[创建个人博客win 10安装Hexo 安装 git 安装 node.js 安装Hexo 123#git bashnpm install hexo-cli -ghexo -v Hexo设置 hexo初始化12hexo init Bloggit clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 参考文件NexT主题文档NexT第三方服务分类和标签底部动画NexT个性化ookamiantd.tophexo+github]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
